* mokuroku
** Implementation
*** Development
**** TODO Read papers on secondary index strategies
***** c.f. http://dblab.cs.ucr.edu/projects/KeyValueIndexes/
***** current impl is akin to "lazy" updates on a stand-alone index
****** index is stored separately from data (column family)
****** appends new index rows on write
****** merges index rows on query
***** based on the Efficient Secondary Attribute Lookup in NoSQL Databases paper
****** the secondary index with lazy updates performs pretty well in most cases
****** their embedded index requires modifying LevelDB internal structures
**** TODO Update stale index entries on =put()=
***** storing a new version of a document may affect the indices
***** maybe store primary key in ~mrview--updated~ cf with timestamp value
***** on query, perform "read repair" of updated entries based on timestamp
**** TODO Remove stale index entries on =delete()=
***** Cassandra does a "read repair" which prunes stale entries on query
***** Diff-Index paper adds index updates to a queue, processes in background
***** some discussions use the term "tombstone" when marking something outdated
***** on =delete()= save the primary key in the ~mrview--deleted~ cf
***** maintain a bloom/cuckoo filter of deleted primary keys
****** https://github.com/seiflotfy/rust-cuckoofilter
****** https://github.com/nervosnetwork/bloom-filters
****** https://github.com/sagalasan/bloom-filter
***** on startup, scan ~mrview--deleted~ to get prime the bloom filter
***** on =query()=, find and remove stale entries for all views, clear deleted rows
***** on =put()= check if key was in deleted set, if so remove ~mrview--deleted~ row
**** TODO Add function to delete an index
***** remove corresponding entry from =views= list
**** TODO Clean up stale indices
***** Called by the application in an ad hoc fashion
***** Delete any column families with our prefix that do not match any registered view
**** TODO Support the =rocksdb::WriteBatch= atomic commit feature
**** TODO Support query with start and end key values/prefixes
**** TODO Support query options to skip some number of results, limit to some number
**** TODO Consider options for thread safe operations
*** Publishing
**** DONE Write a guide on how to use properly
***** Define views at time of DB open
***** Prime the indices at startup to improve response time
**** DONE Start a changelog
**** DONE Write API documentation at the module level
***** assumes we already wrote function-level documentation
**** DONE Write a quick example for the =README.md=
**** DONE Write a simple example crate in =examples= directory
**** DONE Populate =Cargo.toml= with useful meta information
**** DONE Push to GitHub
**** TODO Publish to crates.io
*** Further Work
**** TODO Read the LSM key/value stores research paper on secondary index algorithms
***** Has various approaches to implementing indices
**** TODO Support some form of "reduce" operation, like PouchDB
** Alternative Databases
*** [[https://github.com/spacejam/sled][sled]] is similar to RocksDB, written in Rust
**** would use their ~keyspace~ in place of column families
**** would use their ID generator in place of ULID or whatever
