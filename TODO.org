* mokuroku
** Implementation
*** Development
**** TODO Write the index key/value pairs received in =put()= using a =WriteBatch=
***** probably should batch up for each column family (index)
**** TODO Write a test that rebuilds the index
**** TODO Add function to delete an index
***** remove corresponding entry from =views= list
**** TODO Clean up stale indices
***** Called by the application in an ad hoc fashion
***** Delete any column families with our prefix that do not match any registered view
**** TODO Support the =rocksdb::WriteBatch= atomic commit feature
**** TODO Once =rust-rocksdb= exposes the sequence number, use that instead of timestamp
**** TODO Should have a version number in the database so crate can know to rebuild indices
***** i.e. whenever the format changes, the library should rebuild the index as needed
**** TODO Using some assumed key/value sizes, compute the overhead of the index, add to README
**** TODO Consider using the KMP algorithm to find the index key separator
***** c.f. https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm
**** TODO Support query with start and end key values/prefixes
**** TODO Support query options to skip some number of results, limit to some number
**** TODO Consider options for thread safe operations
*** Publishing
**** DONE Write a guide on how to use properly
***** Define views at time of DB open
***** Prime the indices at startup to improve response time
**** DONE Start a changelog
**** DONE Write API documentation at the module level
***** assumes we already wrote function-level documentation
**** DONE Write a quick example for the =README.md=
**** DONE Write a simple example crate in =examples= directory
**** DONE Populate =Cargo.toml= with useful meta information
**** DONE Push to GitHub
**** DONE Publish to crates.io
**** TODO README should have bullet point feature list
***** bring-your-own-format for keys and values
***** emit zero or more index key and values of your design per data record
***** leverage the serialization you are already using with RocksDB
**** TODO Give an example of how to merge query results a la tanuki tags
**** DONE Add references to the research papers
*** Further Work
**** TODO Read the LSM key/value stores research paper on secondary index algorithms
***** Has various approaches to implementing indices
**** TODO Support some form of "reduce" operation, like PouchDB
** Alternative Databases
*** [[https://github.com/spacejam/sled][sled]] is similar to RocksDB, written in Rust
**** would use their ~keyspace~ in place of column families
